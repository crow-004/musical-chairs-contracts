// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import { MusicalChairsGameV3 } from "contracts/MusicalChairsV3.sol";

/**
 * @title MusicalChairsGameV4
 * @author crow
 * @notice This contract represents version 4 of the game.
 * It transitions the fixed platform commission to a percentage-based model,
 * making the game's economy more flexible and sustainable.
 */
contract MusicalChairsGameV4 is MusicalChairsGameV3 {
    // --- V4 State Variables ---

    /// @notice The percentage of each player's stake taken as platform commission, in basis points (e.g., 50 = 0.5%).
    uint256 public platformCommissionBps;

    // --- V4 Events ---

    /**
     * @notice Emitted when the owner changes the platform commission rate.
     * @param newBps The new platform commission rate in basis points.
     */
    event PlatformCommissionBpsSet(uint256 newBps);

    // --- V4 Custom Errors ---

    error InvalidPlatformCommissionBps();

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initializer for V4. Sets the platform commission rate.
     * @dev The `reinitializer(4)` modifier ensures this can only be called during an upgrade to version 4.
     * @param _initialPlatformCommissionBps The initial platform commission in basis points (e.g., 50 for 0.5%).
     * @custom:oz-upgrades-validate-as-initializer
     */
    function initializeV4(uint256 _initialPlatformCommissionBps) public reinitializer(4) {
        if (_initialPlatformCommissionBps > 10000) revert InvalidPlatformCommissionBps();
        platformCommissionBps = _initialPlatformCommissionBps;
    }

    // --- V4 Owner Functions ---

    /**
     * @notice Allows the owner to set a new platform commission rate.
     * @param _newPlatformCommissionBps The new rate in basis points (e.g., 200 for 2%).
     */
    function setPlatformCommissionBps(uint256 _newPlatformCommissionBps) external onlyOwner {
        if (_newPlatformCommissionBps > 10000) revert InvalidPlatformCommissionBps();
        platformCommissionBps = _newPlatformCommissionBps;
        emit PlatformCommissionBpsSet(_newPlatformCommissionBps);
    }

    // --- V4 Overridden Core Logic ---

    /**
     * @notice Overrides V3 to calculate commission based on a percentage of the stake amount.
     * @dev The fixed `commissionAmount` is no longer used for calculations.
     * @param gameId The ID of the game to record results for.
     * @param winnersArray An array of winner addresses.
     * @param loserAddress The address of the loser.
     */
    function recordResults(uint256 gameId, address[] calldata winnersArray, address loserAddress) public virtual override onlyBackend nonReentrant {
        Game storage game = games[gameId];
        if (game.id == 0) revert GameNotFound();
        if (game.state != GameState.WaitingForDeposits) revert GameNotReadyForResults();
        _validateGameResultsInput(game, winnersArray, loserAddress);

        // --- V4 Commission Logic ---
        // Calculate platform commission based on a percentage of the stake.
        // The commission is calculated from the actual number of players who deposited (`game.depositCount`).
        uint256 totalPlatformCommission = (stakeAmount * game.depositCount * platformCommissionBps) / 10000;

        // --- V4 Referral Logic ---
        // The referral bonus is a percentage of the commission generated BY A SINGLE PLAYER'S STAKE.
        // This prevents the total referral bonus from exceeding a predictable portion of the total commission.
        uint256 totalReferralBonus = 0;
        uint256 referralBonusPerReferredPlayer = 0;

        if (referralCommissionBps > 0 && platformCommissionBps > 0) {
            // 1. Calculate commission generated by one player's stake.
            uint256 commissionPerPlayer = (stakeAmount * platformCommissionBps) / 10000;
            // 2. Calculate the referral bonus as a percentage of that single player's commission.
            referralBonusPerReferredPlayer = (commissionPerPlayer * referralCommissionBps) / 10000;
        }

        if (referralBonusPerReferredPlayer > 0) {
            for (uint256 i = 0; i < game.players.length; ++i) {
                address player = game.players[i];
                if (game.depositedPlayers[player]) {
                    address referrer = playerReferrer[player];
                    if (referrer != address(0) && referrer != NO_REFERRER_SENTINEL) {
                        referralEarnings[referrer] += referralBonusPerReferredPlayer;
                        totalReferralBonus += referralBonusPerReferredPlayer;
                        emit ReferralCommissionPaid(referrer, gameId, referralBonusPerReferredPlayer);
                    }
                }
            }
        }

        // --- V4 Winnings Calculation Logic ---
        // This logic is copied from V1/V2 and adapted for V4's commission model.
        // We do NOT call super.recordResults() as it would recalculate commissions using the old fixed amount.

        uint256 netPlatformCommission = totalPlatformCommission - totalReferralBonus;
        accumulatedCommission += netPlatformCommission;

        // The total pot consists of all deposited stakes.
        uint256 totalPot = stakeAmount * game.depositCount;
        // The net pot available for distribution to winners is the total pot minus the platform's cut.
        uint256 netPotForWinners = totalPot - totalPlatformCommission;

        uint256 amountPerWinner = 0;
        uint256 dust = 0;
        if (winnersArray.length > 0) {
            amountPerWinner = netPotForWinners / winnersArray.length;
            // Calculate the remainder (dust) from the division
            dust = netPotForWinners % winnersArray.length;
        }

        // Add the dust to the platform's commission to ensure the contract balance is zeroed out.
        // This is a standard pattern to handle rounding errors in integer division.
        accumulatedCommission += dust;

        winningsPerWinner[gameId] = amountPerWinner;
        game.state = GameState.Finished;
        game.loser = loserAddress;
        game.endedAt = block.timestamp;

        for (uint256 i = 0; i < winnersArray.length; ++i) {
            game.gameWinners[winnersArray[i]] = true;
        }
        emit GameResultsRecorded(gameId, winnersArray, loserAddress, amountPerWinner);
    }

    /// @notice A simple function to confirm that the contract is V4.
    /// @return bool True if the contract is V4.
    function isVersionFour() public pure returns (bool) {
        return true;
    }
}
